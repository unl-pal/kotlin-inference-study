m: output sum[project: string][filepath: string][class: string][is_inferred: bool][isactualvar: bool][expkind: string][vartype: string][mapval : string] of int;

{@escape@}

name_stack: stack of string;
var_types : map[string] of string;
method_return_types : map[string] of string;

{@project-filter@}
{
    visit(input, visitor {
        before node: CodeRepository -> {
            snapshot := getsnapshot(node, "SOURCE_KOTLIN_1_");
            foreach (i: int; def(snapshot[i]))
                visit(snapshot[i]);
            stop;
        }
        before node: Namespace -> {
            push(name_stack, node.name);
            foreach(i: int; def(node.declarations[i]))
                visit(node.declarations[i]);
        }
        after node: Namespace -> pop(name_stack);
        before node: Declaration -> {
            push(name_stack, node.name);
            fqn := join(".", name_stack);
            var_types[fqn] = string(node.kind);
            decltype := string(node.kind);
        }
        after node: Declaration -> pop(name_stack);
        before node: Method -> {
            push(name_stack, node.name);
            fqn := join(".", name_stack);
            returntype := "unknown";
            if (node.return_type.name != "")
                returntype = node.return_type.name;
            method_return_types[fqn] = returntype;
        }
        after node: Method -> pop(name_stack);
    });

    visit(input, visitor {
        before node: CodeRepository -> {
            snapshot := getsnapshot(node, "SOURCE_KOTLIN_1_");
            foreach (i: int; def(snapshot[i]))
                visit(snapshot[i]);
            stop;
        }
        before node: Namespace -> {
            push(name_stack, node.name);
            foreach(i: int; def(node.declarations[i]))
                visit(node.declarations[i]);
        }
        after node: Namespace -> pop(name_stack);
        before node: Declaration -> {
            push(name_stack, node.name);
        }
        after node: Declaration -> pop(name_stack);
        before node: Method -> {
            push(name_stack, node.name);
        }
        after node: Method -> pop(name_stack);
        before node: Variable -> {
            fqn := join(".", name_stack);
            filepath := current(ChangedFile).name;
            isinferred := !def(node.variable_type);
            isactualvar := false;
            vartype := node.variable_type.name;
            mapval := "none";
            expkind := "none";

            if (def(node.initializer)) {
                expkind = string(node.initializer.kind);

                if (expkind == string(ExpressionKind.METHODCALL)) {
                    if (haskey(method_return_types, fqn)) {
                        mapval = lookup(method_return_types, fqn, "default1");
                    }

                } else if (expkind == string(ExpressionKind.VARACCESS)) {
                    if (haskey(var_types, fqn)) {
                        mapval = lookup(var_types, fqn, "default2");
                    } else {
                        isactualvar = true;
                    }
                }
            }
            m[input.id][escape(filepath)][fqn][isinferred][isactualvar][expkind][vartype][mapval] << 1;
        }
    });
}
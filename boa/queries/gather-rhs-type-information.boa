mrt: output collection[project: string][filepath: string][fqn: string] of string; # return type
decl: output collection[project: string][filepath: string][fqn: string] of string; # decl type

{@escape@}

{@get-method-signature@}

name_stack : stack of string;
types : map[string] of string;

{@project-filter@}
{
    visit(input, visitor {
        before node: CodeRepository -> {
            snapshot := getsnapshot(node, "SOURCE_KOTLIN_1_");
            foreach (i: int; def(snapshot[i]))
                visit(snapshot[i]);
            stop;
        }
        before node: Namespace -> {
            push(name_stack , node.name);
            foreach(i: int; def(node.declarations[i]))
                visit(node.declarations[i]);
        }
        after node: Namespace -> pop(name_stack );
        before node: Declaration -> {
            push(name_stack , node.name);
            fqn := join(".", name_stack );
            file := current(ChangedFile).name;
            types[fqn] = string(node.kind);
            decltype := string(node.kind);
            decl[input.id][escape(file)][fqn] << decltype;
        }
        after node: Declaration -> pop(name_stack );
        before node: Method -> {
            method_signature := getMethodSignature("", "", node);
            push(name_stack, method_signature);
            fqn := join(".", name_stack );
            file := current(ChangedFile).name;
            returntype := "unknown";
            if (node.return_type.name != "")
                returntype = node.return_type.name;
            mrt[input.id][escape(file)][fqn] << returntype;
        }
        after node: Method -> pop(name_stack );
    });
}
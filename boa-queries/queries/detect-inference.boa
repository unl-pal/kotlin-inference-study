o: output sum[project: string][file: string][location: string][isinferred: bool][expKind: string][fqn: string] of int; # Count

is_inferred := function(the_type: Type): bool {
    if (def(the_type)) return false;
    return true;
};

escape := function(s: string): string {
    return strreplace(s, "\\n", "\\\\n", true);
};

location: stack of string;
namestack: stack of string;

getfqn := function(): string {
    return join(".", namestack);
};

visit(input, visitor {
    before node: CodeRepository -> {
        snapshot := getsnapshot(node, "SOURCE_KOTLIN_1_");
        foreach (i: int; def(snapshot[i]))
            visit(snapshot[i]);
        stop;
    }
    before node: Namespace -> {
        push(location, "module");
        push(namestack, node.name);
    }
    after node: Namespace -> {
        pop(location);
        pop(namestack);
    }
    before node: Declaration -> {
        push(namestack, node.name);
        foreach(i: int; def(node.methods[i]))
            visit(node.methods[i]);
        foreach(i: int; def(node.nested_declarations[i]))
            visit(node.nested_declarations[i]);
        pop(namestack);
        stop;
    }
    before node: Method -> {
        push(namestack, node.name);
        file := current(ChangedFile).name;
        place := peek(location);
        isinferred := is_inferred(node.return_type);
        # expKind := string(node.initializer.kind);
        o[input.id][file][place][isinferred]["NA"]["NA"] << 1;
        push(location, "body");
        if (def(node.expression)) visit(node.expression);
        foreach(i: int; def(node.statements[i]))
            visit(node.statements[i]);
        pop(location);
        pop(namestack);
        stop;
    }
    before node: Statement -> {
        if (node.kind == StatementKind.FOR) {
            push(location, "loop_variable");
            if (def(node.variable_declaration))
                visit(node.variable_declaration);
            pop(location);
            foreach(i: int; def(node.expressions[i]))
                visit(node.expressions[i]);
            foreach(i: int; def(node.statements[i]))
                visit(node.statements[i]);
            stop;
        }
    }
    before node: Expression -> {
        if (node.kind == ExpressionKind.LAMBDA) {
            push(location, "lambda_arg");
            foreach(i: int; def(node.variable_decls[i])) {
                visit(node.variable_decls[i]);
            }
            pop(location);
        }
        push(location, "body");
        foreach(i: int; def(node.expressions[i]))
            visit(node.expressions[i]);
        foreach(i: int; def(node.statements[i]))
            visit(node.statements[i]);
        pop(location);
        stop;
    }
    before node: Variable -> {
        file := current(ChangedFile).name;
        place := peek(location);
        isinferred := is_inferred(node.variable_type);
        expKind := string(node.initializer.kind); 
        fqn := getfqn();

        o[input.id][file][place][isinferred][expKind][fqn] << 1;
    }
});